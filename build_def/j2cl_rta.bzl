"""j2cl_rta build rule.

Run the rta algorithm against a call graph generated by j2cl.
"""
_ZipFileInfo = provider()
_J2clRtaInfo = provider()

def _get_transitive_zip_files(srcs_zip_file, targets):
    transitive_zip_files = [target[_ZipFileInfo].transitive_zip_files for target in targets]
    return depset(srcs_zip_file or [], transitive = transitive_zip_files)

def _j2cl_zip_files_aspect_impl(_target, ctx):
    # Because the aspect propagates along "exports", "deps", "modules" and "module_deps" attributes,
    # the aspect has been previously applied to targets listed in those attributes. We can safely
    # assume that _ZipFileInfo exists on those targets.
    targets_with_zip_files = []
    if hasattr(ctx.rule.attr, "exports"):
        targets_with_zip_files += ctx.rule.attr.exports
    if hasattr(ctx.rule.attr, "deps"):
        targets_with_zip_files += ctx.rule.attr.deps
    if hasattr(ctx.rule.attr, "module_deps"):
        targets_with_zip_files += ctx.rule.attr.module_deps
    if hasattr(ctx.rule.attr, "modules"):
        targets_with_zip_files += ctx.rule.attr.modules

    srcs_zip_file = []
    if ctx.rule.kind == "j2cl_library":
        # zip file is always the first file if it's present.
        j2cl_zip_file = _target.files.to_list()[0]
        if j2cl_zip_file and j2cl_zip_file.extension == "zip":
            srcs_zip_file.append(j2cl_zip_file)

    return [_ZipFileInfo(
        transitive_zip_files = _get_transitive_zip_files(srcs_zip_file, targets_with_zip_files),
    )]

_j2cl_zip_files_aspect = aspect(
    attr_aspects = ["deps", "exports", "module_deps", "modules"],
    implementation = _j2cl_zip_files_aspect_impl,
)

def _extract_rta_files(zip_files, ctx):
    rta_files_directory = ctx.actions.declare_directory("%s_rta" % ctx.label.name)
    zip_file_paths = [f.path for f in zip_files]

    # We will unzip the library.json in sub directory created from the short_path of the zip file
    library_info_sub_directories = [f.short_path for f in zip_files]

    ctx.actions.run_shell(
        outputs = [rta_files_directory],
        inputs = zip_files,
        progress_message = "Extract rta files from zip files",
        command = "rta_directory=%s;" % rta_files_directory.path +
                  "rm -rf ${rta_directory}/*;" +
                  "zip_array=(%s);" % " ".join(zip_file_paths) +
                  "sub_dir_array=(%s);" % " ".join(library_info_sub_directories) +
                  "for i in ${!zip_array[@]}; do " +
                  "  target_dir=${rta_directory}/${sub_dir_array[$i]};" +
                  "  mkdir -p ${target_dir};" +
                  "  unzip -q ${zip_array[$i]} libraryinfo.json -d ${target_dir};" +
                  "done;",
    )

    return rta_files_directory

def _j2cl_rta_impl(ctx):
    # our rule can assume that "_ZipFileInfo" provider is present in all of its dependencies because
    # the aspect have been applied on them.
    transitive_zip_files = _get_transitive_zip_files(None, ctx.attr.targets).to_list()
    rta_files_directory = _extract_rta_files(transitive_zip_files, ctx)

    unused_types_list = ctx.outputs.unused_types_list
    unused_members_list = ctx.outputs.unused_members_list
    unused_files_list = ctx.outputs.unused_files_list

    rta_args = ["--unusedTypesOutput", unused_types_list.path]
    rta_args += ["--unusedMembersOutput", unused_members_list.path]
    rta_args += ["--unusedFilesOutput", unused_files_list.path]
    rta_args += [rta_files_directory.path]

    # Run rta algorithm
    ctx.actions.run(
        inputs = [rta_files_directory],
        outputs = [unused_types_list, unused_members_list, unused_files_list],
        arguments = rta_args,
        progress_message = "Running rapid type analysis",
        executable = ctx.executable._rta_runner,
    )

    return [
        _ZipFileInfo(transitive_zip_files = transitive_zip_files),
        _J2clRtaInfo(
            unused_types_list = unused_types_list,
            unused_files_list = unused_files_list,
            unused_members_list = unused_members_list,
        ),
    ]

j2cl_rta = rule(
    attrs = {
        # This is where we initiate the propagation of our aspect. It will be applied on the target
        # listed in our targets attributes and then continue its propagation following "exports",
        # "deps", "modules" and "module_deps" attributes of those targets
        # TODO(b/114732596): Add a check on targets provided in "targets" field.
        "targets": attr.label_list(aspects = [_j2cl_zip_files_aspect]),
        "_rta_runner": attr.label(
            cfg = "host",
            executable = True,
            default = Label(
                "//tools/java/com/google/j2cl/tools/rta:J2clRtaRunner",
            ),
        ),
    },
    outputs = {
        "unused_types_list": "%{name}_unused_types.list",
        "unused_members_list": "%{name}_unused_members.list",
        "unused_files_list": "%{name}_unused_files.list",
    },
    implementation = _j2cl_rta_impl,
)
