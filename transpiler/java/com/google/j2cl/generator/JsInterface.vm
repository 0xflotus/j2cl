#set ($utilAlias = ${statementSourceGenerator.toSource($nativeUtilTypeDecriptor)} )
#set ($classAlias = ${statementSourceGenerator.toSource($javaLangClassTypeDecriptor)} )
#set ($interfaceName = ${statementSourceGenerator.toSource($classType.Descriptor)})
#set ($mangledName = ${ManglingNameUtils.getMangledName($classType.Descriptor)})
#set ($simpleName = $classType.Descriptor.SimpleName)
#set ($binaryName = ${GeneratorUtils.getBinaryName($classType.Descriptor)})
#set ($sourceName = ${GeneratorUtils.getSourceName($classType.Descriptor)})
/**
 * @interface
#if (${classType.Descriptor.isParameterizedType()})
 * @template ${statementSourceGenerator.getJsDocNames($classType.Descriptor.getTypeArgumentDescriptors())}
#end
#foreach ($superInterfaceTypeDescriptor in $classType.SuperInterfaceTypeDescriptors)
 * @extends {${statementSourceGenerator.getJsDocName($superInterfaceTypeDescriptor, true)}}
#end
 */
class $interfaceName {
#foreach($method in $classType.Methods)
#parse( "com/google/j2cl/generator/JsMethod.vm" )

#end
  /**
   * Marks the provided class as implementing this interface.
   * @param {Function} classConstructor
   * @public
   */
  static $markImplementor(classConstructor) {
#foreach ($superInterfaceTypeDescriptor in $classType.SuperInterfaceTypeDescriptors)
    ${statementSourceGenerator.toSource($superInterfaceTypeDescriptor)}.$markImplementor(classConstructor);
#end
    /**
     * @public {boolean}
     */
    classConstructor.prototype
        .$implements__$mangledName = true;
  }

  /**
   * Returns whether the provided instance is of a class that implements this
   * interface.
   * @return {boolean}
   * @public
   * @nocollapse
   */
  static $isInstance(instance) {
    return instance != null &&
           instance.$implements__$mangledName;
  }

  /**
   * Returns whether the provided class is or extends this class.
   * @param {Function} classConstructor
   * @return {boolean}
   * @public
   * @nocollapse
   */
  static $isAssignableFrom(classConstructor) {
    return classConstructor != null &&
           classConstructor.prototype
               .$implements__$mangledName;
  }

  /**
   * @return {${classAlias}}
   * @public
   * @nocollapse
   */
  static $getClass() {
    $interfaceName.$clinit();
    if (!${interfaceName}.$class${interfaceName}_) {
      ${interfaceName}.$class${interfaceName}_ = $classAlias.$createForInterface(
          $utilAlias.$generateId('$simpleName'),
          $utilAlias.$generateId('$binaryName'), null,
          $utilAlias.$generateId('$sourceName'));
    }
    return ${interfaceName}.$class${interfaceName}_;
  }

#parse( "com/google/j2cl/generator/JsClinit.vm")
};


/**
 * The class literal field.
 * @private {$classAlias}
 */
${interfaceName}.$class${interfaceName}_ = null;


## TODO: remove cast after b/20102666 is handled in Closure.
$interfaceName.$markImplementor(/** @type {Function} */($interfaceName));
