#set ($interfaceName = ${statementSourceGenerator.toSource($classType.Descriptor)})
#set ($mangledName = ${ManglingNameUtils.getMangledName($classType.Descriptor)})
#set ($simpleName = $classType.Descriptor.SimpleName)
#set ($binaryName = $classType.Descriptor.BinaryName)
#set ($sourceName = ${TranspilerUtils.getSourceName($classType.Descriptor)})
/**
 * @interface
#foreach ($superInterfaceTypeDescriptor in $classType.SuperInterfaceTypeDescriptors)
 * @extends {${statementSourceGenerator.toSource($superInterfaceTypeDescriptor)}}
#end
 */
class $interfaceName {
#foreach($method in $classType.Methods)
#parse( "com/google/j2cl/generator/JsMethod.vm" )

#end
  /**
   * Marks the provided class as implementing this interface.
   * @param {Function} classConstructor
   * @public
   */
  static $markImplementor(classConstructor) {
#foreach ($superInterfaceTypeDescriptor in $classType.SuperInterfaceTypeDescriptors)
    ${statementSourceGenerator.toSource($superInterfaceTypeDescriptor)}.$markImplementor(classConstructor);
#end
    /**
     * @public {boolean}
     */
    classConstructor.prototype
        .$implements__$mangledName = true;
  }

  /**
   * Returns whether the provided instance is of a class that implements this
   * interface.
   * @return {boolean}
   * @public
   */
  static $isInstance(instance) {
    return instance != null &&
           instance.$implements__$mangledName;
  }

  /**
   * Returns whether the provided class is or extends this class.
   * @param {Function} classConstructor
   * @return {boolean}
   * @private
   */
  static $isAssignableFrom(classConstructor) {
    return classConstructor != null &&
           classConstructor.prototype
               .$implements__$mangledName;
  }

  /**
   * Runs inline static field initializers.
##* @clinit to make js lint pass, removed the @clinit. we may get it back once it is supported.
   * @protected
   */
  static $clinit() {}
};


$interfaceName.$markImplementor($interfaceName);


#set ($classAlias = ${statementSourceGenerator.toSource($javaLangClassTypeDecriptor)} )
#set ($utilAlias = ${statementSourceGenerator.toSource($nativeUtilTypeDecriptor)} )
/**
 * @public {${classAlias}}
 */
$interfaceName.$class = $classAlias.$createForInterface(
    $utilAlias.$generateId('$simpleName'),
    $utilAlias.$generateId('$binaryName'), null,
    $utilAlias.$generateId('$sourceName'));
