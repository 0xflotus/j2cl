#set ($utilAlias = ${sourceGenerator.toSource($nativeUtilTypeDecriptor)} )
#set ($classAlias = ${sourceGenerator.toSource($javaLangClassTypeDecriptor)} )
#set ($superTypeDescriptor = $classType.SuperTypeDescriptor)
#if ($superTypeDescriptor)
#set ($superTypeName = ${sourceGenerator.toSource($superTypeDescriptor)})
#set ($superTypeMangledName = ${ManglingNameUtils.getMangledName($superTypeDescriptor)})
#set ($extendsClause = "extends " + $superTypeName)
#else
#set ($extendsClause = "")
#end
#set ($className = ${sourceGenerator.toSource($classType.Descriptor)})
#set ($jsDocName = ${sourceGenerator.getJsDocName(${classType.Descriptor}, true)})
#set ($mangledTypeName = ${ManglingNameUtils.getMangledName($classType.Descriptor)})
#set ($simpleName = $classType.Descriptor.SimpleName)
#set ($binaryName = ${GeneratorUtils.getBinaryName($classType.Descriptor)})
#set ($sourceName = ${GeneratorUtils.getSourceName($classType.Descriptor)})
#set ($isBoxedTypeAsPrimitive = ${GeneratorUtils.isBoxedTypeAsPrimitive($classType.Descriptor)})
#set ($superBoxedTypeAsPrimitive = ${GeneratorUtils.superBoxedTypeAsPrimitive($classType.Descriptor)})
#if (${GeneratorUtils.hasJsDoc($classType)})
/**
#if (${classType.isAbstract()})
 * Abstract class, do not instantiate.
#end
#if (${classType.Descriptor.isParameterizedType()})
 * @template ${sourceGenerator.getJsDocNames($classType.Descriptor.getTypeArgumentDescriptors())}
#end
#if (${classType.SuperTypeDescriptor.isParameterizedType()})
 * @extends {${sourceGenerator.getJsDocName($classType.SuperTypeDescriptor, true)}}
#end
#foreach ($superInterfaceTypeDescriptor in $classType.SuperInterfaceTypeDescriptors)
 * @implements {${sourceGenerator.getJsDocName($superInterfaceTypeDescriptor, true)}}
#end
 */
#end
class $className $extendsClause {
  /**
   * Defines instance fields.
   * @private
   */
  constructor() {
#if ($superTypeDescriptor)
    super();
#end
#foreach ($field in $classType.getInstanceFields())
#set ($fieldVisibility = $field.Descriptor.Visibility)
#set ($fieldType = ${sourceGenerator.getJsDocName($field.Descriptor.TypeDescriptor)})
#set ($fieldName = ${ManglingNameUtils.getMangledName($field.Descriptor)})
#set ($initialValue = ${GeneratorUtils.getInitialValue($field)})
    /**
     * @$fieldVisibility {$fieldType}
     */
    this.$fieldName = ${sourceGenerator.toSource($initialValue)};
#end
  }

  /**
   * Runs instance field and block initializers.
   * @private
   */
  $init__$mangledTypeName() {
#foreach ($field in $classType.getInstanceFields())
#if ($field.hasInitializer())
#if (!$field.isCompileTimeConstant())
#set ($fieldInitializer = $sourceGenerator.toSource($field.Initializer))
    this.${ManglingNameUtils.getMangledName($field.Descriptor)} = $fieldInitializer;
#end
#end
#end
#foreach ($instanceInitializerBlock in $classType.InstanceInitializerBlocks)
#foreach ($statementInInitializer in $instanceInitializerBlock.Statements)
    $sourceGenerator.toSource($statementInInitializer)
#end
#end
  }

#foreach($method in $classType.Methods)
#if($method.isConstructor())
#parse( "com/google/j2cl/generator/JsConstructorMethods.vm" )
#else
#parse( "com/google/j2cl/generator/JsMethod.vm" )
#end
#end
#if ($superBoxedTypeAsPrimitive)
  /**
   * $isInstance() function implementation is provided separately.
   */
#else
  /**
   * Returns whether the provided instance is an instance of this class.
   * @return {boolean}
   * @public
   */
#if (${classType.Descriptor.isJsFunctionImplementation()})
  static $isInstance(instance) {
    return instance != null &&
           instance.$is__$mangledTypeName;
  }
#else
  static $isInstance(instance) { return instance instanceof $className; }
#end
#end

  /**
   * Returns whether the provided class is or extends this class.
   * @param {Function} classConstructor
   * @return {boolean}
   * @public
   */
  static $isAssignableFrom(classConstructor) {
    return ${utilAlias}.$canCastClass(classConstructor, $className);
  }
#if (${classType.Descriptor.isJsFunctionImplementation()})

  /**
   * Copies the fields from {@code from} to {@code to}.
   * @param {${className}} from
   * @param {*} to
   * @public
   */
  static $copy(from, to) {
#foreach ($field in $classType.getInstanceFields())
#set ($fieldName = ${ManglingNameUtils.getMangledName($field.Descriptor)})
    to.$fieldName = from.$fieldName;
#end
    // Marks the object is an instance of this class.
    to.$is__$mangledTypeName = true;
    // TODO: may copy Objects methods (equals, hashCode, etc. ) as well.
  }
#end

  /**
   * @return {${classAlias}}
   * @public
   */
#if (${classType.isEnum()})
  static $getClass() {
    $className.$clinit();
    if (!${className}.$class${className}_) {
      ${className}.$class${className}_ = $classAlias.$createForEnum(
          $utilAlias.$generateId('$simpleName'),
          $utilAlias.$generateId('$binaryName'),
          $utilAlias.$generateId('$sourceName'),
          // TODO(rluble): emit here the enum values
          null);
    }
    return ${className}.$class${className}_;
  }
#else
  static $getClass() {
    $className.$clinit();
    if (!${className}.$class${className}_) {
      ${className}.$class${className}_ = $classAlias.$createForClass(
          $utilAlias.$generateId('$simpleName'),
          $utilAlias.$generateId('$binaryName'),
          $utilAlias.$generateId('$sourceName'));
    }
    return ${className}.$class${className}_;
  }
#end

  /**
   * @override
   * @return {${classAlias}}
   * @public
   */
  m_getClass() { return ${className}.$getClass(); }

#parse( "com/google/j2cl/generator/JsClinit.vm")
};
#foreach ($staticField in $classType.getStaticFields())
#parse( "com/google/j2cl/generator/JsStaticField.vm" )
#end


/**
 * The class literal field.
 * @private {$classAlias}
 */
${className}.$class${className}_ = null;


#foreach ($superInterfaceTypeDescriptor in $classType.SuperInterfaceTypeDescriptors)
#if (!${superInterfaceTypeDescriptor.isNative()})
${sourceGenerator.toSource($superInterfaceTypeDescriptor)}.$markImplementor($className);


#end
#end
